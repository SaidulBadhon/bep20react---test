"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const penpal_1 = __importDefault(require("penpal"));
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const moment_1 = __importDefault(require("moment"));
const is_buffer_1 = __importDefault(require("is-buffer"));
const utils_1 = require("./utils");
const AuthereumProvider_1 = __importDefault(require("./AuthereumProvider"));
const config_1 = require("./config");
const Notifier_1 = __importDefault(require("./Notifier"));
const version_1 = __importDefault(require("./version"));
// Serialize object for postMessage to iframe.
// Converts references to values.
const serializeMessageObj = (obj) => {
    const tx = {};
    for (let k in obj) {
        let v = obj[k];
        if (typeof v === 'object' && v.toString === 'function') {
            v = v.toString('hex');
        }
        tx[k] = v;
    }
    return tx;
};
class Authereum extends eventemitter3_1.default {
    constructor(config) {
        super();
        this.blockedPopupRedirect = true;
        this.notificationsMap = {};
        // NOTE: to prevent pop-ups from being blocked, there must be no awaits from
        // click to window.open, meaning value lookups must be cached before the
        // login method is called.
        this.login = utils_1.throttle(() => __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            if (!this.cachedIsAuthenticated) {
                // NOTE: if not logged in to dapp, then proceed to login
                yield this.signLoginKeyRequest(this.cachedLoginKeyAddress);
                return this.getAuthenticatedAccount();
            }
            else {
                this.notifier.notify('success', 'You are logged into Authereum', { timeout: 5000 });
            }
            // await first
            const account = yield this.getAuthenticatedAccount();
            return account;
        }), 250);
        this.signWithDappKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.signWithLoginKey(message));
        }), 250);
        this.signWithLoginKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signWithLoginKey()` is deprecated. Use `authereum.signWithDappKey()` instead.');
            return this.signWithDappKey(message);
        }), 250);
        this.signTypedMessageWithDappKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.signTypedMessageWithLoginKey(message));
        }), 250);
        this.signMessageWithAdminKey = utils_1.throttle((message) => __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            const url = this.getSignWithAdminKeyUri(message);
            const result = yield this.openPopupOrRedirect(url);
            return result.signature;
        }), 250);
        this.signTransactionWithLoginKey = utils_1.throttle((tx) => __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.signTransactionWithLoginKey(serializeMessageObj(tx), true));
        }), 250);
        this.sendTransaction = utils_1.throttle((tx) => __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.executeLoginKeyMetaTx(serializeMessageObj(tx)));
        }), 250);
        this.setConfig(config);
        this.setupNotifier();
    }
    // NOTE: keep this sync
    setConfig(config) {
        if (typeof config === 'string') {
            let network = config;
            this.networkName = (network || '').trim().toLowerCase();
            if (['mainnet', 'ropsten', 'rinkeby', 'kovan', 'goerli'].includes(this.networkName)) {
                this.apiUri = config_1.defaultConfig.apiUri(this.networkName);
                this.rpcUri = config_1.defaultConfig.rpcUri(this.networkName);
                this.webUri = config_1.defaultConfig.webUri(this.networkName);
                this.xsUri = config_1.defaultConfig.xsUri(this.networkName);
            }
            else if (config === 'localhost') {
                this.apiUri = 'http://localhost:4000';
                this.rpcUri = 'https://kovan.rpc.authereum.com';
                this.webUri = 'http://localhost:3000';
                this.xsUri = 'http://localhost:3002';
                this.networkName = 'kovan';
            }
            else {
                throw new Error('Unsupported network');
            }
        }
        else {
            config = config || {};
            this.networkName = config.networkName || 'mainnet';
            this.rpcUri = config.rpcUri || config_1.defaultConfig.rpcUri(this.networkName);
            this.webUri = config.webUri || config_1.defaultConfig.webUri(this.networkName);
            this.xsUri = config.xsUri || config_1.defaultConfig.xsUri(this.networkName);
            this.disableNotifications = config.disableNotifications;
            if (typeof config.blockedPopupRedirect === 'boolean') {
                this.blockedPopupRedirect = config.blockedPopupRedirect;
            }
        }
        this.networkId = config_1.defaultConfig.networkId(this.networkName);
        if (config.redirectUri) {
            this.redirectUri = config.redirectUri;
        }
        else {
            this.redirectUri = window.location.href;
        }
        this.cacheReady = false;
        this.iframeReady = false;
        this.readyEmitted = false;
        this._widgetEnabled = false;
        this.iframeStyle = {
            width: 0,
            height: 0,
            top: 0,
            left: 0
        };
        this.redirectUri = this.redirectUri || window.location.href;
        this.provider = new AuthereumProvider_1.default(this);
        this.connectToChildIframe();
        this.setupCache();
        this.setupResizeListener();
        this.emitReadyEvent();
    }
    setupCache() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this.cacheLoginKeyAddress(),
                this.cacheIsAuthenticated(),
                this.cacheAccountAddress()
            ]);
            this.cacheReady = true;
        });
    }
    resetCache() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setupCache();
        });
    }
    setupNotifier() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilDomReady();
            this.notifier = new Notifier_1.default({
                networkId: this.networkId,
                disableNotifications: this.disableNotifications
            });
        });
    }
    setupResizeListener() {
        return __awaiter(this, void 0, void 0, function* () {
            window.addEventListener('resize', utils_1.debounce((event) => __awaiter(this, void 0, void 0, function* () {
                yield this.tilIframeReady();
                if (this.childIframeConnection.onResize) {
                    const size = yield this.getWindowSize();
                    this.childIframeConnection.onResize(size);
                }
            }), 100));
        });
    }
    cacheLoginKeyAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilIframeReady();
            let loginKey = yield this.childIframeConnection.getOrCreateLoginKey();
            this.cachedLoginKeyAddress = loginKey.publicAddress;
        });
    }
    cacheAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilIframeReady();
            const accountAddress = yield this.childIframeConnection.getAccountAddress();
            this.cachedAccountAddress = accountAddress;
        });
    }
    cacheIsAuthenticated() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilIframeReady();
            this.cachedIsAuthenticated = yield this.isAuthenticated();
        });
    }
    authenticate() {
        return __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.authenticate()` is deprecated. Use `authereum.login()` instead.');
            return this.login();
        });
    }
    isAuthenticated() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilIframeReady();
            return this.handleError(this.childIframeConnection.isAuthenticated());
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            const res = yield this.childIframeConnection.logout();
            this.resetCache();
            this.emit('logout', {});
            return res;
        });
    }
    getAuthenticatedAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getAuthenticatedAccount());
        });
    }
    getDappKey() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getLoginKey());
        });
    }
    getLoginKey() {
        return __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.getLoginKey()` is deprecated. Use `authereum.getDappKey()` instead.');
            return this.getDappKey();
        });
    }
    getLoginKeyAuthSignature() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getLoginKeyAuthSignature());
        });
    }
    getLoginKeyRestrictionData() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getLoginKeyRestrictionData());
        });
    }
    getAccountAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getAccountAddress());
        });
    }
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getBalance());
        });
    }
    getRpcUri() {
        return this.rpcUri;
    }
    getNetworkId() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getNetworkId());
        });
    }
    getProvider() {
        return this.provider;
    }
    handleError(promise) {
        return __awaiter(this, void 0, void 0, function* () {
            return promise
                .catch((err) => {
                this.emit('error', err);
                if (err.message.includes('Login key is no longer active')) {
                    this.notifier.notify('error', 'Log back into Authereum to continue', { timeout: 5000 });
                    this.logout();
                }
                else {
                    this.notifier.notify('error', err.message, { timeout: 5000 });
                }
            });
        });
    }
    isReady() {
        return this.iframeReady && this.cacheReady;
    }
    updateConfig(config) {
        this.setConfig(config);
    }
    getConfig() {
        return {
            apiUri: this.apiUri,
            rpcUri: this.rpcUri,
            webUri: this.webUri,
            xsUri: this.xsUri,
            networkName: this.networkName,
            networkId: config_1.defaultConfig.networkId(this.networkName),
            disableNotifications: this.disableNotifications
        };
    }
    showWidget(enabled = true) {
        if (!enabled) {
            return this.hideWidget();
        }
        this._widgetEnabled = true;
        this.refreshWidget();
        return true;
    }
    hideWidget() {
        this._widgetEnabled = false;
        // this.setIframePositionTop(this.getWindowHeight())
        // this.setIframePositionLeft(this.getWindowWidth())
        this.setIframeWidth(0);
        this.setIframeHeight(0);
        return true;
    }
    widgetEnabled() {
        return this._widgetEnabled;
    }
    tilIframeReady() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.iframeReady) {
                yield utils_1.wait(100);
                return this.tilIframeReady();
            }
            yield utils_1.wait(100);
            return true;
        });
    }
    tilReady() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isReady()) {
                yield utils_1.wait(100);
                return this.tilReady();
            }
            yield utils_1.wait(100);
            return true;
        });
    }
    emitReadyEvent() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            if (this.readyEmitted)
                return;
            this.readyEmitted = true;
            this.emit('ready', {});
        });
    }
    connectToChildIframe() {
        return __awaiter(this, void 0, void 0, function* () {
            const iframe = yield this.getOrCreateIframe();
            this.iframeConnection = penpal_1.default.connectToChild({
                iframe,
                timeout: 60e3,
                methods: {
                    onError: (err) => __awaiter(this, void 0, void 0, function* () {
                        // TODO: button with link in toaster
                        // window.open('https://support.authereum.com/hc/en-us/articles/360036310154-How-can-I-enable-cookies-')
                        this.emit('error', err);
                        this.notifier.notify('error', err.message);
                    }),
                    onLogout: () => __awaiter(this, void 0, void 0, function* () {
                        this.resetCache();
                        this.emit('logout', {});
                    }),
                    onDappKeyExpired: (loginKeyAddress) => __awaiter(this, void 0, void 0, function* () {
                        if (loginKeyAddress === this.cachedLoginKeyAddress) {
                            this.resetCache();
                            this.emit('dappKeyExpired', loginKeyAddress);
                        }
                    }),
                    login: () => __awaiter(this, void 0, void 0, function* () {
                        return this.login();
                    }),
                    /*
                    setWidgetPosition: (position: IPosition) => {
                      const { x, y } = position
                      this.iframeStyle.left = x
                      this.iframeStyle.top = y
                      // this.refreshWidget()
                    },
                     */
                    setWidgetSize: (size) => {
                        const { width, height } = size;
                        this.iframeStyle.width = width;
                        this.iframeStyle.height = height;
                        this.refreshWidget();
                    },
                    getWindowSize: () => __awaiter(this, void 0, void 0, function* () {
                        return this.getWindowSize();
                    }),
                    hideWidget: () => {
                        this.hideWidget();
                    },
                    postMessage: (data) => {
                        return this.handlePostMessage(data);
                    }
                }
            });
            this.iframeConnection.promise.then(child => {
                this.iframeReady = true;
                this.childIframeConnection = child;
            })
                // TODO: only log error if not 'connection destroyed' error.
                // Eat error for now to not spam dapp.
                // tslint:disable-next-line
                .catch(err => { });
        });
    }
    getOrCreateIframe() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.iframe) {
                if (this.iframeConnection) {
                    this.iframeConnection.destroy();
                }
                this.iframe.remove();
            }
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const id = `authereum__x-iframe--${Date.now()}`;
                const iframe = document.createElement('iframe');
                iframe.id = id;
                iframe.src = this.xsUri;
                iframe.style.position = 'fixed';
                iframe.style.bottom = '0';
                iframe.style.right = '0';
                iframe.style.width = '0';
                iframe.style.height = '0';
                iframe.style.border = '0';
                iframe.style.background = 'transparent';
                iframe.style.zIndex = '1';
                iframe.setAttribute('frameborder', '0');
                iframe.setAttribute('scrolling', 'no');
                // iframe.style.outline = '1px solid red' // debug
                this.iframe = iframe;
                resolve(this.iframe);
                yield this.tilDomReady();
                document.body.appendChild(iframe);
                iframe.onload = () => {
                    this.emit('iframeReady', {});
                    this.postVersionToChild();
                };
            }));
        });
    }
    postVersionToChild() {
        return this.postMessageToChild({
            method: 'version',
            params: this.version()
        });
    }
    postMessageToChild(data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.postMessage(data));
        });
    }
    handlePostMessage(data) {
        try {
            const { method, params } = data;
            if (method === 'notification') {
                return this.handlePostMessageNotification(params);
            }
            else if (method === 'updateIdNotification') {
                return this.handlePostMessageUpdateIdNotification(params);
            }
            else if (method === 'updateNotification') {
                return this.handlePostMessageUpdateNotification(params);
            }
            else if (method === 'dismissNotification') {
                return this.handlePostMessageDismissNotification(params);
            }
            else if (method === 'log') {
                return this.handlePostMessageLog(params);
            }
        }
        catch (err) {
            // noop
        }
    }
    handlePostMessageNotification(data) {
        let { id, type, message, timeout } = data;
        if (!type) {
            type = 'success';
        }
        if (!timeout) {
            timeout = 5e3;
        }
        const notification = this.notifier.notify(type, message, { timeout });
        if (id) {
            this.notificationsMap[data.id] = notification;
        }
    }
    handlePostMessageUpdateIdNotification(data) {
        let { id, oldId } = data;
        this.notificationsMap[id] = this.notificationsMap[oldId];
    }
    handlePostMessageUpdateNotification(data) {
        const { id, eventCode, type, message, autoDismiss } = data;
        const notification = this.notificationsMap[id];
        if (notification) {
            notification.update({
                eventCode,
                type,
                message,
                autoDismiss
            });
        }
    }
    handlePostMessageDismissNotification(data) {
        const { id } = data;
        const notification = this.notificationsMap[id];
        if (notification) {
            notification.dismiss();
        }
    }
    handlePostMessageLog(data) {
        let { type, message } = data;
        if (!type) {
            type = 'log';
        }
        console[type](message);
    }
    getWindowSize() {
        return {
            width: this.getWindowWidth(),
            height: this.getWindowHeight()
        };
    }
    getWindowWidth() {
        return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    }
    getWindowHeight() {
        return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    }
    /*
  public setIframePositionTop (y: number) {
    if (!this.iframe) return
    this.iframe.style.top = `${y}px`
  }
     */
    setIframePositionLeft(x) {
        if (!this.iframe)
            return;
        this.iframe.style.left = `${x}px`;
    }
    setIframeWidth(width) {
        if (!this.iframe)
            return;
        this.iframe.style.width = `${width}px`;
    }
    setIframeHeight(height) {
        if (!this.iframe)
            return;
        this.iframe.style.height = `${height}px`;
    }
    refreshWidget() {
        if (!this._widgetEnabled)
            return;
        const { top, left, width, height } = this.iframeStyle;
        // this.setIframePositionTop(top)
        // this.setIframePositionLeft(left)
        this.setIframeWidth(width);
        this.setIframeHeight(height);
    }
    loginKeyExists() {
        return __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getLoginKey());
        });
    }
    accountAddressExists() {
        return __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getAccountAddress());
        });
    }
    getAccountAdminKeyNonce() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getAccountAuthKeyNonce());
        });
    }
    getAccountAuthKeyNonce() {
        return __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.getAccountAuthKeyNonce()` is deprecated. Use `authereum.getAccountAdminKeyNonce()` instead.');
            return this.getAccountAdminKeyNonce();
        });
    }
    executeLoginKeyMetaTx(tx, signOnly) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.executeLoginKeyMetaTx(serializeMessageObj(tx), signOnly));
        });
    }
    loadLoginKey(loginKey) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.loadLoginKey(loginKey));
        });
    }
    getOrCreateLoginKey() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tilReady();
            return this.handleError(this.childIframeConnection.getOrCreateLoginKey());
        });
    }
    getAuthenticateUri(loginKeyAddress) {
        // NOTE: slk = sign login key
        return this.webUri + '/?slk=' + encodeURIComponent(JSON.stringify({
            loginKey: {
                publicAddress: loginKeyAddress,
                // Convert to UTC to avoid local machine timezones
                expiresAt: moment_1.default().add(1, 'month').utc().unix()
            }
        })) + '&redirect_uri=' + this.redirectUri;
    }
    getSignWithAdminKeyUri(message) {
        if (is_buffer_1.default(message)) {
            message = `0x${message.toString('hex')}`;
        }
        // NOTE: sm = sign message
        return this.webUri + '/?sm=' + encodeURIComponent(JSON.stringify({
            message
        })) + '&redirect_uri=' + this.redirectUri;
    }
    openPopupOrRedirect(url) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('openPopup', {});
            const child = window.open(url, 'Authereum', `toolbar=no,
      location=no,
      status=no,
      menubar=no,
      scrollbars=no,
      resizable=no,
      width=470,
      height=640`);
            const isBlocked = (child === null || child === undefined);
            if (isBlocked && !this.blockedPopupRedirect) {
                const err = new Error('Disable popup blocker and try again');
                this.notifier.notify('error', err.message, { timeout: 5000 });
                throw err;
            }
            else if (isBlocked) {
                // NOTE: if window is blocked then resort to redirect
                window.location.href = url;
                return;
            }
            child.focus();
            return new Promise((resolve, reject) => {
                const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    if (child.closed) {
                        cleanUp();
                        const err = new Error('Window closed');
                        this.emit('error', err);
                        this.emit('closePopup', {});
                        reject(err);
                    }
                }), 250);
                const timeout = setTimeout(() => {
                    cleanUp();
                    child.close();
                    doneWithError(new Error('Timedout'));
                }, 10 * 60 * 1000);
                const cleanUp = () => {
                    clearInterval(interval);
                    clearTimeout(timeout);
                    this.emit('closePopup', {});
                };
                const doneWithError = (err) => {
                    cleanUp();
                    child.close();
                    this.emit('error', err);
                    reject(err);
                };
                const done = (result) => {
                    cleanUp();
                    // NOTE: As of Chrome 77, this needs to be called twice if dev tools are open
                    // NOTE: https://support.google.com/chrome/thread/2241373?hl=en
                    child.close();
                    child.close();
                    resolve(result);
                };
                window.addEventListener('message', event => {
                    if (event.origin.includes(this.webUri)) {
                        if (event.data.login) {
                            done({ success: true });
                            this.emit('login', {});
                            this.cachedIsAuthenticated = true;
                            if (this.redirectUri !== window.location.href) {
                                window.location.href = this.redirectUri;
                            }
                        }
                        else if (event.data.result) {
                            done(event.data.result);
                            if (this.redirectUri !== window.location.href) {
                                window.location.href = this.redirectUri;
                            }
                        }
                        else if (event.data.error) {
                            doneWithError(new Error(event.data.error));
                            if (this.redirectUri !== window.location.href) {
                                window.location.href = this.redirectUri;
                            }
                        }
                    }
                });
            });
        });
    }
    signLoginKeyRequest(publicAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.getAuthenticateUri(publicAddress);
            return this.openPopupOrRedirect(url);
        });
    }
    tilDomReady() {
        return new Promise((resolve) => {
            if (document.readyState !== 'loading') {
                resolve();
            }
            else {
                document.addEventListener('DOMContentLoaded', () => resolve());
            }
        });
    }
    version() {
        return version_1.default;
    }
}
exports.default = Authereum;
if (typeof window !== 'undefined') {
    window.Authereum = Authereum;
}
