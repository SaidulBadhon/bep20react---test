import SturdyWebSocket from 'sturdy-websocket';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var version = "0.2.3";

var session = {
    socket: null,
    pendingSocketConnection: false,
    socketConnection: false,
    networkId: 1,
    dappId: '',
    connectionId: '',
    clients: [],
    status: {
        nodeSynced: true,
        connected: false
    }
};

function createEmitter() {
    return {
        listeners: {},
        on: function (eventCode, listener) {
            // check if valid eventCode
            switch (eventCode) {
                case 'txSent':
                case 'txPool':
                case 'txConfirmed':
                case 'txSpeedUp':
                case 'txCancel':
                case 'txFailed':
                case 'all':
                    break;
                default:
                    throw new Error(eventCode + " is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk");
            }
            // check that listener is a function
            if (typeof listener !== 'function') {
                throw new Error('Listener must be a function');
            }
            // add listener for the eventCode
            this.listeners[eventCode] = listener;
        },
        emit: function (state) {
            if (this.listeners[state.eventCode]) {
                return this.listeners[state.eventCode](state);
            }
            if (this.listeners.all) {
                return this.listeners.all(state);
            }
        }
    };
}
function createEventLog(msg) {
    var dappId = session.dappId, networkId = session.networkId;
    return JSON.stringify(__assign({ timeStamp: new Date(), dappId: dappId,
        version: version, blockchain: {
            system: 'ethereum',
            network: networkName(networkId)
        } }, msg));
}
function networkName(id) {
    switch (id) {
        case 1:
            return 'main';
        case 3:
            return 'ropsten';
        case 4:
            return 'rinkeby';
        case 5:
            return 'goerli';
        case 42:
            return 'kovan';
        default:
            return 'local';
    }
}
function serverEcho(eventCode) {
    switch (eventCode) {
        case 'txRequest':
        case 'nsfFail':
        case 'txRepeat':
        case 'txAwaitingApproval':
        case 'txConfirmReminder':
        case 'txSendFail':
        case 'txError':
        case 'txUnderPriced':
        case 'txSent':
            return true;
        default:
            return false;
    }
}
function last(arr) {
    return arr.reverse()[0];
}

function sendMessage(msg) {
    session.socket.send(createEventLog(msg));
}
function handleMessage(msg) {
    var _a = JSON.parse(msg.data), status = _a.status, reason = _a.reason, event = _a.event, nodeSyncStatus = _a.nodeSyncStatus, connectionId = _a.connectionId;
    if (connectionId) {
        if (typeof window !== 'undefined') {
            window.localStorage.setItem('connectionId', connectionId);
        }
        else {
            session.connectionId = connectionId;
        }
    }
    // handle node sync status change
    if (nodeSyncStatus !== undefined &&
        nodeSyncStatus.blockchain === 'ethereum' &&
        nodeSyncStatus.network === networkName(session.networkId)) {
        session.status.nodeSynced = nodeSyncStatus.synced;
    }
    // handle any errors from the server
    if (status === 'error') {
        if (reason.includes('not a valid API key')) {
            var errorObj = new Error(reason);
            throw errorObj;
        }
        if (reason.includes('network not supported')) {
            var errorObj = new Error(reason);
            throw errorObj;
        }
        if (reason.includes('maximum allowed amount')) {
            var errorObj = new Error(reason);
            throw errorObj;
        }
    }
    if (event && event.transaction) {
        var transaction_1 = event.transaction, eventCode = event.eventCode, contractCall = event.contractCall;
        // flatten in to one object
        var newState_1 = __assign(__assign({}, transaction_1), { eventCode: eventCode, contractCall: contractCall });
        // ignore server echo messages
        if (serverEcho(eventCode)) {
            return;
        }
        // handle change of hash in speedup and cancel events
        if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {
            session.clients.forEach(function (client) {
                client.transactions = client.transactions.map(function (tx) {
                    if (tx.hash === transaction_1.originalHash) {
                        // reassign hash parameter in transaction queue to new hash
                        tx.hash = transaction_1.hash;
                    }
                    return tx;
                });
            });
        }
        var watchedAddress_1 = transaction_1.watchedAddress && transaction_1.watchedAddress.toLowerCase();
        if (watchedAddress_1) {
            session.clients.forEach(function (client) {
                var transactionHandlers = client.transactionHandlers, accounts = client.accounts;
                var accountObj = accounts.find(function (ac) { return ac.address === watchedAddress_1; });
                // no accountObj then this client isn't concerned with this notification
                if (!accountObj)
                    return;
                var emitterResult = accountObj && last(accountObj.emitters.map(function (emitter) { return emitter.emit(newState_1); }));
                transactionHandlers.forEach(function (handler) {
                    return handler({ transaction: newState_1, emitterResult: emitterResult });
                });
            });
        }
        else {
            session.clients.forEach(function (client) {
                var transactionHandlers = client.transactionHandlers, transactions = client.transactions;
                var transactionObj = transactions.find(function (tx) { return tx.hash === transaction_1.hash; });
                // no transactionObj then this client isn't concerned with this notification
                if (!transactionObj)
                    return;
                var emitterResult = transactionObj && transactionObj.emitter.emit(newState_1);
                transactionHandlers.forEach(function (handler) {
                    return handler({ transaction: newState_1, emitterResult: emitterResult });
                });
            });
        }
    }
}

function validateType(options) {
    var name = options.name, value = options.value, type = options.type, optional = options.optional, customValidation = options.customValidation;
    if (!optional && typeof value === 'undefined') {
        throw new Error("\"" + name + "\" is required");
    }
    if (typeof value !== 'undefined' &&
        (type === 'array' ? Array.isArray(type) : typeof value !== type)) {
        throw new Error("\"" + name + "\" must be of type: " + type + ", received type: " + typeof value + " from value: " + value);
    }
    if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {
        throw new Error("\"" + value + "\" is not a valid \"" + name + "\"");
    }
}
function validateOptions(options) {
    validateType({ name: 'sdk options', value: options, type: 'object' });
    var dappId = options.dappId, networkId = options.networkId, transactionHandler = options.transactionHandler, apiUrl = options.apiUrl, ws = options.ws;
    validateType({ name: 'dappId', value: dappId, type: 'string' });
    validateType({ name: 'networkId', value: networkId, type: 'number' });
    validateType({
        name: 'transactionHandler',
        value: transactionHandler,
        type: 'function',
        optional: true
    });
    validateType({ name: 'apiUrl', value: apiUrl, type: 'string', optional: true });
    validateType({ name: 'ws', value: ws, type: 'function', optional: true });
}
function validateTransaction(clientIndex, hash, id) {
    validateType({ name: 'clientIndex', value: clientIndex, type: 'number' });
    validateType({ name: 'hash', value: hash, type: 'string', customValidation: validTxHash });
    validateType({ name: 'id', value: id, type: 'string', optional: true });
}
function validateAccount(clientIndex, address) {
    validateType({ name: 'clientIndex', value: clientIndex, type: 'number' });
    validateType({ name: 'address', value: address, type: 'string', customValidation: isAddress });
}
function validateEvent(eventObj) {
    validateType({ name: 'eventObj', value: eventObj, type: 'object' });
    var eventCode = eventObj.eventCode, categoryCode = eventObj.categoryCode, transaction = eventObj.transaction, wallet = eventObj.wallet, contract = eventObj.contract;
    validateType({ name: 'eventCode', value: eventCode, type: 'string' });
    validateType({ name: 'categoryCode', value: categoryCode, type: 'string' });
    validateType({ name: 'transaction', value: transaction, type: 'object', optional: true });
    if (transaction) {
        var id = transaction.id, to = transaction.to, from = transaction.from, value = transaction.value, gas = transaction.gas, gasPrice = transaction.gasPrice, nonce = transaction.nonce, status_1 = transaction.status, startTime = transaction.startTime;
        validateType({ name: 'id', value: id, type: 'string', optional: true });
        validateType({
            name: 'to',
            value: to,
            type: 'string',
            optional: true,
            customValidation: isAddress
        });
        validateType({
            name: 'from',
            value: from,
            type: 'string',
            optional: true,
            customValidation: isAddress
        });
        validateType({ name: 'value', value: value, type: 'string', optional: true });
        validateType({ name: 'gas', value: gas, type: 'string', optional: true });
        validateType({ name: 'gasPrice', value: gasPrice, type: 'string', optional: true });
        validateType({ name: 'nonce', value: nonce, type: 'number', optional: true });
        validateType({ name: 'status', value: status_1, type: 'string', optional: true });
        validateType({ name: 'startTime', value: startTime, type: 'number', optional: true });
    }
    validateType({ name: 'wallet', value: wallet, type: 'object', optional: true });
    if (wallet) {
        var balance = wallet.balance;
        validateType({ name: 'balance', value: balance, type: 'string', optional: true });
    }
    validateType({ name: 'contract', value: contract, type: 'object', optional: true });
    if (contract) {
        var methodName = contract.methodName, parameters = contract.parameters;
        validateType({ name: 'methodName', value: methodName, type: 'string', optional: true });
        validateType({ name: 'parameters', value: parameters, type: 'array', optional: true });
    }
}
function isAddress(address) {
    return /^(0x)?[0-9a-fA-F]{40}$/.test(address);
}
function validTxHash(hash) {
    return /^0x([A-Fa-f0-9]{64})$/.test(hash);
}

function transaction(clientIndex, hash, id) {
    validateTransaction(clientIndex, hash, id);
    // create startTime for transaction
    var startTime = Date.now();
    // create emitter for transaction
    var emitter = createEmitter();
    // create eventCode for transaction
    var eventCode = 'txSent';
    var client = session.clients[clientIndex];
    // put in queue
    client.transactions.push({
        hash: hash,
        emitter: emitter
    });
    var transaction = {
        hash: hash,
        id: id || hash,
        startTime: startTime,
        status: 'sent'
    };
    var newState = __assign(__assign({}, transaction), { eventCode: eventCode });
    // logEvent to server
    sendMessage({
        eventCode: eventCode,
        categoryCode: 'activeTransaction',
        transaction: transaction
    });
    var transactionObj = {
        details: transaction,
        emitter: emitter
    };
    // emit after delay to allow for listener to be registered
    setTimeout(function () {
        var emitterResult = emitter.emit(newState);
        client.transactionHandlers.forEach(function (handler) {
            return handler({ transaction: newState, emitterResult: emitterResult });
        });
    }, 5);
    return transactionObj;
}

function account(clientIndex, address) {
    validateAccount(clientIndex, address);
    // lowercase the address
    address = address.toLowerCase();
    // create emitter for transaction
    var emitter = createEmitter();
    // create eventCode for transaction
    var eventCode = 'accountAddress';
    var existingAddressWatcher = session.clients[clientIndex].accounts.find(function (ac) { return ac.address === address; });
    if (existingAddressWatcher) {
        // add to existing emitters array
        existingAddressWatcher.emitters.push(emitter);
    }
    else {
        // put in accounts queue
        session.clients[clientIndex].accounts.push({
            address: address,
            emitters: [emitter]
        });
    }
    // logEvent to server
    sendMessage({
        eventCode: eventCode,
        categoryCode: 'watch',
        account: {
            address: address
        }
    });
    return {
        emitter: emitter,
        details: {
            address: address
        }
    };
}

function event(eventObj) {
    validateEvent(eventObj);
    sendMessage(eventObj);
}

var clientIndex = 0;
function sdk(options) {
    validateOptions(options);
    var dappId = options.dappId, networkId = options.networkId, _a = options.transactionHandlers, transactionHandlers = _a === void 0 ? [] : _a, apiUrl = options.apiUrl, ws = options.ws;
    var alreadyConnected = !!session.socket;
    session.dappId = dappId;
    session.networkId = networkId;
    session.clients.push({
        transactionHandlers: transactionHandlers,
        transactions: [],
        accounts: []
    });
    if (!alreadyConnected) {
        if (ws) {
            session.socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', {
                wsConstructor: ws
            });
        }
        else {
            session.socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0');
        }
        session.socket.onopen = function () {
            session.status.connected = true;
            var connectionId = (typeof window !== 'undefined' && window.localStorage.getItem('connectionId')) ||
                session.connectionId;
            sendMessage({
                categoryCode: 'initialize',
                eventCode: 'checkDappId',
                connectionId: connectionId
            });
        };
        session.socket.ondown = function () {
            session.status.connected = false;
        };
        session.socket.onreopen = function () {
            session.status.connected = true;
            var connectionId = (typeof window !== 'undefined' && window.localStorage.getItem('connectionId')) ||
                session.connectionId;
            sendMessage({
                categoryCode: 'initialize',
                eventCode: 'checkDappId',
                connectionId: connectionId
            });
            // re-register all accounts to be watched by server upon
            // re-connection as they don't get transferred over automatically
            // to the new connection like tx hashes do
            session.clients.forEach(function (client) {
                client.accounts.forEach(function (account) {
                    sendMessage({
                        eventCode: 'accountAddress',
                        categoryCode: 'watch',
                        account: {
                            address: account.address
                        }
                    });
                });
            });
        };
        session.socket.onmessage = handleMessage;
    }
    return {
        transaction: transaction,
        account: account,
        event: event,
        status: session.status,
        clientIndex: clientIndex++
    };
}

export default sdk;
//# sourceMappingURL=bnc-sdk.es5.js.map
