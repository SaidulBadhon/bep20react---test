(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.bncSdk = factory());
}(this, function () { 'use strict';

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Used by `_.defaults` to customize its `_.assignIn` use.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to assign.
	 * @param {Object} object The parent object of `objValue`.
	 * @returns {*} Returns the value to assign.
	 */
	function assignInDefaults(objValue, srcValue, key, object) {
	  if (objValue === undefined ||
	      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	    return srcValue;
	  }
	  return objValue;
	}

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    object[key] = value;
	  }
	}

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = array;
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    assignValue(object, key, newValue === undefined ? source[key] : newValue);
	  }
	  return object;
	}

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * This method is like `_.assignIn` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extendWith
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignInWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	  copyObject(source, keysIn(source), object, customizer);
	});

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(args) {
	  args.push(undefined, assignInDefaults);
	  return apply(assignInWith, undefined, args);
	});

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	var lodash_defaults = defaults;

	var dist = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	var SHOULD_RECONNECT_FALSE_MESSAGE = "Provided shouldReconnect() returned false. Closing permanently.";
	var SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = "Provided shouldReconnect() resolved to false. Closing permanently.";
	var SturdyWebSocket = /** @class */ (function () {
	    function SturdyWebSocket(url, protocolsOrOptions, options) {
	        this.url = url;
	        this.onclose = null;
	        this.onerror = null;
	        this.onmessage = null;
	        this.onopen = null;
	        this.ondown = null;
	        this.onreopen = null;
	        this.CONNECTING = SturdyWebSocket.CONNECTING;
	        this.OPEN = SturdyWebSocket.OPEN;
	        this.CLOSING = SturdyWebSocket.CLOSING;
	        this.CLOSED = SturdyWebSocket.CLOSED;
	        this.hasBeenOpened = false;
	        this.isClosed = false;
	        this.messageBuffer = [];
	        this.nextRetryTime = 0;
	        this.reconnectCount = 0;
	        this.lastKnownExtensions = "";
	        this.lastKnownProtocol = "";
	        this.listeners = {};
	        if (protocolsOrOptions == null ||
	            typeof protocolsOrOptions === "string" ||
	            Array.isArray(protocolsOrOptions)) {
	            this.protocols = protocolsOrOptions;
	        }
	        else {
	            options = protocolsOrOptions;
	        }
	        this.options = lodash_defaults({}, options, SturdyWebSocket.DEFAULT_OPTIONS);
	        if (!this.options.wsConstructor) {
	            if (typeof WebSocket !== "undefined") {
	                this.options.wsConstructor = WebSocket;
	            }
	            else {
	                throw new Error("WebSocket not present in global scope and no " +
	                    "wsConstructor option was provided.");
	            }
	        }
	        this.openNewWebSocket();
	    }
	    Object.defineProperty(SturdyWebSocket.prototype, "binaryType", {
	        get: function () {
	            return this.binaryTypeInternal || "blob";
	        },
	        set: function (binaryType) {
	            this.binaryTypeInternal = binaryType;
	            if (this.ws) {
	                this.ws.binaryType = binaryType;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SturdyWebSocket.prototype, "bufferedAmount", {
	        get: function () {
	            var sum = this.ws ? this.ws.bufferedAmount : 0;
	            var hasUnknownAmount = false;
	            this.messageBuffer.forEach(function (data) {
	                var byteLength = getDataByteLength(data);
	                if (byteLength != null) {
	                    sum += byteLength;
	                }
	                else {
	                    hasUnknownAmount = true;
	                }
	            });
	            if (hasUnknownAmount) {
	                this.debugLog("Some buffered data had unknown length. bufferedAmount()" +
	                    " return value may be below the correct amount.");
	            }
	            return sum;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SturdyWebSocket.prototype, "extensions", {
	        get: function () {
	            return this.ws ? this.ws.extensions : this.lastKnownExtensions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SturdyWebSocket.prototype, "protocol", {
	        get: function () {
	            return this.ws ? this.ws.protocol : this.lastKnownProtocol;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SturdyWebSocket.prototype, "readyState", {
	        get: function () {
	            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SturdyWebSocket.prototype.close = function (code, reason) {
	        if (this.ws) {
	            this.ws.close(code, reason);
	        }
	        this.shutdown();
	        this.debugLog("WebSocket permanently closed by client.");
	    };
	    SturdyWebSocket.prototype.send = function (data) {
	        if (this.ws && this.ws.readyState === this.OPEN) {
	            this.ws.send(data);
	        }
	        else {
	            this.messageBuffer.push(data);
	        }
	    };
	    SturdyWebSocket.prototype.addEventListener = function (type, listener) {
	        if (!this.listeners[type]) {
	            this.listeners[type] = [];
	        }
	        this.listeners[type].push(listener);
	    };
	    SturdyWebSocket.prototype.dispatchEvent = function (event) {
	        return this.dispatchEventOfType(event.type, event);
	    };
	    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {
	        if (this.listeners[type]) {
	            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });
	        }
	    };
	    SturdyWebSocket.prototype.openNewWebSocket = function () {
	        var _this = this;
	        if (this.isClosed) {
	            return;
	        }
	        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;
	        this.debugLog("Opening new WebSocket to " + this.url + ".");
	        var ws = new wsConstructor(this.url, this.protocols);
	        ws.onclose = function (event) { return _this.handleClose(event); };
	        ws.onerror = function (event) { return _this.handleError(event); };
	        ws.onmessage = function (event) { return _this.handleMessage(event); };
	        ws.onopen = function (event) { return _this.handleOpen(event); };
	        this.connectTimeoutId = setTimeout(function () {
	            // If this is running, we still haven't opened the websocket.
	            // Kill it so we can try again.
	            _this.clearConnectTimeout();
	            ws.close();
	        }, connectTimeout);
	        this.ws = ws;
	    };
	    SturdyWebSocket.prototype.handleOpen = function (event) {
	        var _this = this;
	        if (!this.ws || this.isClosed) {
	            return;
	        }
	        var allClearResetTime = this.options.allClearResetTime;
	        this.debugLog("WebSocket opened.");
	        if (this.binaryTypeInternal != null) {
	            this.ws.binaryType = this.binaryTypeInternal;
	        }
	        else {
	            this.binaryTypeInternal = this.ws.binaryType;
	        }
	        this.clearConnectTimeout();
	        if (this.hasBeenOpened) {
	            this.dispatchEventOfType("reopen", event);
	        }
	        else {
	            this.dispatchEventOfType("open", event);
	            this.hasBeenOpened = true;
	        }
	        this.messageBuffer.forEach(function (message) { return _this.send(message); });
	        this.messageBuffer = [];
	        this.allClearTimeoutId = setTimeout(function () {
	            _this.clearAllClearTimeout();
	            _this.nextRetryTime = 0;
	            _this.reconnectCount = 0;
	            var openTime = (allClearResetTime / 1000) | 0;
	            _this.debugLog("WebSocket remained open for " + openTime + " seconds. Resetting" +
	                " retry time and count.");
	        }, allClearResetTime);
	    };
	    SturdyWebSocket.prototype.handleMessage = function (event) {
	        if (this.isClosed) {
	            return;
	        }
	        this.dispatchEventOfType("message", event);
	    };
	    SturdyWebSocket.prototype.handleClose = function (event) {
	        var _this = this;
	        if (this.isClosed) {
	            return;
	        }
	        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;
	        this.clearConnectTimeout();
	        this.clearAllClearTimeout();
	        if (this.ws) {
	            this.lastKnownExtensions = this.ws.extensions;
	            this.lastKnownProtocol = this.ws.protocol;
	            this.ws = undefined;
	        }
	        this.dispatchEventOfType("down", event);
	        if (this.reconnectCount >= maxReconnectAttempts) {
	            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());
	            return;
	        }
	        var willReconnect = shouldReconnect(event);
	        if (typeof willReconnect === "boolean") {
	            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);
	        }
	        else {
	            willReconnect.then(function (willReconnectResolved) {
	                if (_this.isClosed) {
	                    return;
	                }
	                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);
	            });
	        }
	    };
	    SturdyWebSocket.prototype.handleError = function (event) {
	        this.dispatchEventOfType("error", event);
	        this.debugLog("WebSocket encountered an error.");
	    };
	    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {
	        if (willReconnect) {
	            this.reconnect();
	        }
	        else {
	            this.stopReconnecting(event, denialReason);
	        }
	    };
	    SturdyWebSocket.prototype.reconnect = function () {
	        var _this = this;
	        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;
	        this.reconnectCount++;
	        var retryTime = this.nextRetryTime;
	        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));
	        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);
	        var retryTimeSeconds = (retryTime / 1000) | 0;
	        this.debugLog("WebSocket was closed. Re-opening in " + retryTimeSeconds + " seconds.");
	    };
	    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {
	        this.debugLog(debugReason);
	        this.shutdown();
	        this.dispatchEventOfType("close", event);
	    };
	    SturdyWebSocket.prototype.shutdown = function () {
	        this.isClosed = true;
	        this.clearAllTimeouts();
	        this.messageBuffer = [];
	    };
	    SturdyWebSocket.prototype.clearAllTimeouts = function () {
	        this.clearConnectTimeout();
	        this.clearAllClearTimeout();
	    };
	    SturdyWebSocket.prototype.clearConnectTimeout = function () {
	        if (this.connectTimeoutId != null) {
	            clearTimeout(this.connectTimeoutId);
	            this.connectTimeoutId = undefined;
	        }
	    };
	    SturdyWebSocket.prototype.clearAllClearTimeout = function () {
	        if (this.allClearTimeoutId != null) {
	            clearTimeout(this.allClearTimeoutId);
	            this.allClearTimeoutId = undefined;
	        }
	    };
	    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {
	        var _this = this;
	        switch (type) {
	            case "close":
	                if (this.onclose) {
	                    this.onclose(event);
	                }
	                break;
	            case "error":
	                if (this.onerror) {
	                    this.onerror(event);
	                }
	                break;
	            case "message":
	                if (this.onmessage) {
	                    this.onmessage(event);
	                }
	                break;
	            case "open":
	                if (this.onopen) {
	                    this.onopen(event);
	                }
	                break;
	            case "down":
	                if (this.ondown) {
	                    this.ondown(event);
	                }
	                break;
	            case "reopen":
	                if (this.onreopen) {
	                    this.onreopen(event);
	                }
	                break;
	        }
	        if (type in this.listeners) {
	            this.listeners[type]
	                .slice()
	                .forEach(function (listener) { return _this.callListener(listener, event); });
	        }
	        return !event || !event.defaultPrevented;
	    };
	    SturdyWebSocket.prototype.callListener = function (listener, event) {
	        if (typeof listener === "function") {
	            listener.call(this, event);
	        }
	        else {
	            listener.handleEvent.call(this, event);
	        }
	    };
	    SturdyWebSocket.prototype.debugLog = function (message) {
	        if (this.options.debug) {
	            // tslint:disable-next-line:no-console
	            console.log(message);
	        }
	    };
	    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {
	        var maxReconnectAttempts = this.options.maxReconnectAttempts;
	        return "Failed to reconnect after " + maxReconnectAttempts + " " + pluralize("attempt", maxReconnectAttempts) + ". Closing permanently.";
	    };
	    SturdyWebSocket.DEFAULT_OPTIONS = {
	        allClearResetTime: 5000,
	        connectTimeout: 5000,
	        debug: false,
	        minReconnectDelay: 1000,
	        maxReconnectDelay: 30000,
	        maxReconnectAttempts: Number.POSITIVE_INFINITY,
	        reconnectBackoffFactor: 1.5,
	        shouldReconnect: function () { return true; },
	        wsConstructor: undefined,
	    };
	    SturdyWebSocket.CONNECTING = 0;
	    SturdyWebSocket.OPEN = 1;
	    SturdyWebSocket.CLOSING = 2;
	    SturdyWebSocket.CLOSED = 3;
	    return SturdyWebSocket;
	}());
	exports.default = SturdyWebSocket;
	function getDataByteLength(data) {
	    if (typeof data === "string") {
	        // UTF-16 strings use two bytes per character.
	        return 2 * data.length;
	    }
	    else if (data instanceof ArrayBuffer) {
	        return data.byteLength;
	    }
	    else if (data instanceof Blob) {
	        return data.size;
	    }
	    else {
	        return undefined;
	    }
	}
	function pluralize(s, n) {
	    return n === 1 ? s : s + "s";
	}

	});

	var SturdyWebSocket = unwrapExports(dist);

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	var version = "0.2.3";

	var session = {
	    socket: null,
	    pendingSocketConnection: false,
	    socketConnection: false,
	    networkId: 1,
	    dappId: '',
	    connectionId: '',
	    clients: [],
	    status: {
	        nodeSynced: true,
	        connected: false
	    }
	};

	function createEmitter() {
	    return {
	        listeners: {},
	        on: function (eventCode, listener) {
	            // check if valid eventCode
	            switch (eventCode) {
	                case 'txSent':
	                case 'txPool':
	                case 'txConfirmed':
	                case 'txSpeedUp':
	                case 'txCancel':
	                case 'txFailed':
	                case 'all':
	                    break;
	                default:
	                    throw new Error(eventCode + " is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk");
	            }
	            // check that listener is a function
	            if (typeof listener !== 'function') {
	                throw new Error('Listener must be a function');
	            }
	            // add listener for the eventCode
	            this.listeners[eventCode] = listener;
	        },
	        emit: function (state) {
	            if (this.listeners[state.eventCode]) {
	                return this.listeners[state.eventCode](state);
	            }
	            if (this.listeners.all) {
	                return this.listeners.all(state);
	            }
	        }
	    };
	}
	function createEventLog(msg) {
	    var dappId = session.dappId, networkId = session.networkId;
	    return JSON.stringify(__assign({ timeStamp: new Date(), dappId: dappId,
	        version: version, blockchain: {
	            system: 'ethereum',
	            network: networkName(networkId)
	        } }, msg));
	}
	function networkName(id) {
	    switch (id) {
	        case 1:
	            return 'main';
	        case 3:
	            return 'ropsten';
	        case 4:
	            return 'rinkeby';
	        case 5:
	            return 'goerli';
	        case 42:
	            return 'kovan';
	        default:
	            return 'local';
	    }
	}
	function serverEcho(eventCode) {
	    switch (eventCode) {
	        case 'txRequest':
	        case 'nsfFail':
	        case 'txRepeat':
	        case 'txAwaitingApproval':
	        case 'txConfirmReminder':
	        case 'txSendFail':
	        case 'txError':
	        case 'txUnderPriced':
	        case 'txSent':
	            return true;
	        default:
	            return false;
	    }
	}
	function last(arr) {
	    return arr.reverse()[0];
	}

	function sendMessage(msg) {
	    session.socket.send(createEventLog(msg));
	}
	function handleMessage(msg) {
	    var _a = JSON.parse(msg.data), status = _a.status, reason = _a.reason, event = _a.event, nodeSyncStatus = _a.nodeSyncStatus, connectionId = _a.connectionId;
	    if (connectionId) {
	        if (typeof window !== 'undefined') {
	            window.localStorage.setItem('connectionId', connectionId);
	        }
	        else {
	            session.connectionId = connectionId;
	        }
	    }
	    // handle node sync status change
	    if (nodeSyncStatus !== undefined &&
	        nodeSyncStatus.blockchain === 'ethereum' &&
	        nodeSyncStatus.network === networkName(session.networkId)) {
	        session.status.nodeSynced = nodeSyncStatus.synced;
	    }
	    // handle any errors from the server
	    if (status === 'error') {
	        if (reason.includes('not a valid API key')) {
	            var errorObj = new Error(reason);
	            throw errorObj;
	        }
	        if (reason.includes('network not supported')) {
	            var errorObj = new Error(reason);
	            throw errorObj;
	        }
	        if (reason.includes('maximum allowed amount')) {
	            var errorObj = new Error(reason);
	            throw errorObj;
	        }
	    }
	    if (event && event.transaction) {
	        var transaction_1 = event.transaction, eventCode = event.eventCode, contractCall = event.contractCall;
	        // flatten in to one object
	        var newState_1 = __assign(__assign({}, transaction_1), { eventCode: eventCode, contractCall: contractCall });
	        // ignore server echo messages
	        if (serverEcho(eventCode)) {
	            return;
	        }
	        // handle change of hash in speedup and cancel events
	        if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {
	            session.clients.forEach(function (client) {
	                client.transactions = client.transactions.map(function (tx) {
	                    if (tx.hash === transaction_1.originalHash) {
	                        // reassign hash parameter in transaction queue to new hash
	                        tx.hash = transaction_1.hash;
	                    }
	                    return tx;
	                });
	            });
	        }
	        var watchedAddress_1 = transaction_1.watchedAddress && transaction_1.watchedAddress.toLowerCase();
	        if (watchedAddress_1) {
	            session.clients.forEach(function (client) {
	                var transactionHandlers = client.transactionHandlers, accounts = client.accounts;
	                var accountObj = accounts.find(function (ac) { return ac.address === watchedAddress_1; });
	                // no accountObj then this client isn't concerned with this notification
	                if (!accountObj)
	                    return;
	                var emitterResult = accountObj && last(accountObj.emitters.map(function (emitter) { return emitter.emit(newState_1); }));
	                transactionHandlers.forEach(function (handler) {
	                    return handler({ transaction: newState_1, emitterResult: emitterResult });
	                });
	            });
	        }
	        else {
	            session.clients.forEach(function (client) {
	                var transactionHandlers = client.transactionHandlers, transactions = client.transactions;
	                var transactionObj = transactions.find(function (tx) { return tx.hash === transaction_1.hash; });
	                // no transactionObj then this client isn't concerned with this notification
	                if (!transactionObj)
	                    return;
	                var emitterResult = transactionObj && transactionObj.emitter.emit(newState_1);
	                transactionHandlers.forEach(function (handler) {
	                    return handler({ transaction: newState_1, emitterResult: emitterResult });
	                });
	            });
	        }
	    }
	}

	function validateType(options) {
	    var name = options.name, value = options.value, type = options.type, optional = options.optional, customValidation = options.customValidation;
	    if (!optional && typeof value === 'undefined') {
	        throw new Error("\"" + name + "\" is required");
	    }
	    if (typeof value !== 'undefined' &&
	        (type === 'array' ? Array.isArray(type) : typeof value !== type)) {
	        throw new Error("\"" + name + "\" must be of type: " + type + ", received type: " + typeof value + " from value: " + value);
	    }
	    if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {
	        throw new Error("\"" + value + "\" is not a valid \"" + name + "\"");
	    }
	}
	function validateOptions(options) {
	    validateType({ name: 'sdk options', value: options, type: 'object' });
	    var dappId = options.dappId, networkId = options.networkId, transactionHandler = options.transactionHandler, apiUrl = options.apiUrl, ws = options.ws;
	    validateType({ name: 'dappId', value: dappId, type: 'string' });
	    validateType({ name: 'networkId', value: networkId, type: 'number' });
	    validateType({
	        name: 'transactionHandler',
	        value: transactionHandler,
	        type: 'function',
	        optional: true
	    });
	    validateType({ name: 'apiUrl', value: apiUrl, type: 'string', optional: true });
	    validateType({ name: 'ws', value: ws, type: 'function', optional: true });
	}
	function validateTransaction(clientIndex, hash, id) {
	    validateType({ name: 'clientIndex', value: clientIndex, type: 'number' });
	    validateType({ name: 'hash', value: hash, type: 'string', customValidation: validTxHash });
	    validateType({ name: 'id', value: id, type: 'string', optional: true });
	}
	function validateAccount(clientIndex, address) {
	    validateType({ name: 'clientIndex', value: clientIndex, type: 'number' });
	    validateType({ name: 'address', value: address, type: 'string', customValidation: isAddress });
	}
	function validateEvent(eventObj) {
	    validateType({ name: 'eventObj', value: eventObj, type: 'object' });
	    var eventCode = eventObj.eventCode, categoryCode = eventObj.categoryCode, transaction = eventObj.transaction, wallet = eventObj.wallet, contract = eventObj.contract;
	    validateType({ name: 'eventCode', value: eventCode, type: 'string' });
	    validateType({ name: 'categoryCode', value: categoryCode, type: 'string' });
	    validateType({ name: 'transaction', value: transaction, type: 'object', optional: true });
	    if (transaction) {
	        var id = transaction.id, to = transaction.to, from = transaction.from, value = transaction.value, gas = transaction.gas, gasPrice = transaction.gasPrice, nonce = transaction.nonce, status_1 = transaction.status, startTime = transaction.startTime;
	        validateType({ name: 'id', value: id, type: 'string', optional: true });
	        validateType({
	            name: 'to',
	            value: to,
	            type: 'string',
	            optional: true,
	            customValidation: isAddress
	        });
	        validateType({
	            name: 'from',
	            value: from,
	            type: 'string',
	            optional: true,
	            customValidation: isAddress
	        });
	        validateType({ name: 'value', value: value, type: 'string', optional: true });
	        validateType({ name: 'gas', value: gas, type: 'string', optional: true });
	        validateType({ name: 'gasPrice', value: gasPrice, type: 'string', optional: true });
	        validateType({ name: 'nonce', value: nonce, type: 'number', optional: true });
	        validateType({ name: 'status', value: status_1, type: 'string', optional: true });
	        validateType({ name: 'startTime', value: startTime, type: 'number', optional: true });
	    }
	    validateType({ name: 'wallet', value: wallet, type: 'object', optional: true });
	    if (wallet) {
	        var balance = wallet.balance;
	        validateType({ name: 'balance', value: balance, type: 'string', optional: true });
	    }
	    validateType({ name: 'contract', value: contract, type: 'object', optional: true });
	    if (contract) {
	        var methodName = contract.methodName, parameters = contract.parameters;
	        validateType({ name: 'methodName', value: methodName, type: 'string', optional: true });
	        validateType({ name: 'parameters', value: parameters, type: 'array', optional: true });
	    }
	}
	function isAddress(address) {
	    return /^(0x)?[0-9a-fA-F]{40}$/.test(address);
	}
	function validTxHash(hash) {
	    return /^0x([A-Fa-f0-9]{64})$/.test(hash);
	}

	function transaction(clientIndex, hash, id) {
	    validateTransaction(clientIndex, hash, id);
	    // create startTime for transaction
	    var startTime = Date.now();
	    // create emitter for transaction
	    var emitter = createEmitter();
	    // create eventCode for transaction
	    var eventCode = 'txSent';
	    var client = session.clients[clientIndex];
	    // put in queue
	    client.transactions.push({
	        hash: hash,
	        emitter: emitter
	    });
	    var transaction = {
	        hash: hash,
	        id: id || hash,
	        startTime: startTime,
	        status: 'sent'
	    };
	    var newState = __assign(__assign({}, transaction), { eventCode: eventCode });
	    // logEvent to server
	    sendMessage({
	        eventCode: eventCode,
	        categoryCode: 'activeTransaction',
	        transaction: transaction
	    });
	    var transactionObj = {
	        details: transaction,
	        emitter: emitter
	    };
	    // emit after delay to allow for listener to be registered
	    setTimeout(function () {
	        var emitterResult = emitter.emit(newState);
	        client.transactionHandlers.forEach(function (handler) {
	            return handler({ transaction: newState, emitterResult: emitterResult });
	        });
	    }, 5);
	    return transactionObj;
	}

	function account(clientIndex, address) {
	    validateAccount(clientIndex, address);
	    // lowercase the address
	    address = address.toLowerCase();
	    // create emitter for transaction
	    var emitter = createEmitter();
	    // create eventCode for transaction
	    var eventCode = 'accountAddress';
	    var existingAddressWatcher = session.clients[clientIndex].accounts.find(function (ac) { return ac.address === address; });
	    if (existingAddressWatcher) {
	        // add to existing emitters array
	        existingAddressWatcher.emitters.push(emitter);
	    }
	    else {
	        // put in accounts queue
	        session.clients[clientIndex].accounts.push({
	            address: address,
	            emitters: [emitter]
	        });
	    }
	    // logEvent to server
	    sendMessage({
	        eventCode: eventCode,
	        categoryCode: 'watch',
	        account: {
	            address: address
	        }
	    });
	    return {
	        emitter: emitter,
	        details: {
	            address: address
	        }
	    };
	}

	function event(eventObj) {
	    validateEvent(eventObj);
	    sendMessage(eventObj);
	}

	var clientIndex = 0;
	function sdk(options) {
	    validateOptions(options);
	    var dappId = options.dappId, networkId = options.networkId, _a = options.transactionHandlers, transactionHandlers = _a === void 0 ? [] : _a, apiUrl = options.apiUrl, ws = options.ws;
	    var alreadyConnected = !!session.socket;
	    session.dappId = dappId;
	    session.networkId = networkId;
	    session.clients.push({
	        transactionHandlers: transactionHandlers,
	        transactions: [],
	        accounts: []
	    });
	    if (!alreadyConnected) {
	        if (ws) {
	            session.socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', {
	                wsConstructor: ws
	            });
	        }
	        else {
	            session.socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0');
	        }
	        session.socket.onopen = function () {
	            session.status.connected = true;
	            var connectionId = (typeof window !== 'undefined' && window.localStorage.getItem('connectionId')) ||
	                session.connectionId;
	            sendMessage({
	                categoryCode: 'initialize',
	                eventCode: 'checkDappId',
	                connectionId: connectionId
	            });
	        };
	        session.socket.ondown = function () {
	            session.status.connected = false;
	        };
	        session.socket.onreopen = function () {
	            session.status.connected = true;
	            var connectionId = (typeof window !== 'undefined' && window.localStorage.getItem('connectionId')) ||
	                session.connectionId;
	            sendMessage({
	                categoryCode: 'initialize',
	                eventCode: 'checkDappId',
	                connectionId: connectionId
	            });
	            // re-register all accounts to be watched by server upon
	            // re-connection as they don't get transferred over automatically
	            // to the new connection like tx hashes do
	            session.clients.forEach(function (client) {
	                client.accounts.forEach(function (account) {
	                    sendMessage({
	                        eventCode: 'accountAddress',
	                        categoryCode: 'watch',
	                        account: {
	                            address: account.address
	                        }
	                    });
	                });
	            });
	        };
	        session.socket.onmessage = handleMessage;
	    }
	    return {
	        transaction: transaction,
	        account: account,
	        event: event,
	        status: session.status,
	        clientIndex: clientIndex++
	    };
	}

	return sdk;

}));
//# sourceMappingURL=bnc-sdk.js.map
